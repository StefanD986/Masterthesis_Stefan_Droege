\subsection{Tracking}
Die Acquisition ist wie beschrieben ein relativ aufwändiger Prozess, und wird lediglich durchgeführt, wenn neue GPS Satelliten gesucht werden, beispielsweise nach dem Systemstart, oder wenn das Signal verloren wird. Sobald die Parameter (PRN, Codephase, Dopplershift) durch die Acquisition bestimmt wurden, werden diese an den eigentlichen Demodulator, den Trackingloop, weitergegeben. Der Begriff Trackingloop kommt daher, dass die bei der Acquisition bestimmte Codephase bzw. Dopplershift jeweils nur Momentaufnahmen sind. Dopplershift und Codephase ändern sich ständig und auch Ungenauigkeiten der Takterzeugung beim Empfänger müssen ausgeglichen werden. Der Trackingloop hat die Aufgabe die in der Acquisitonphase bestimmten Werte mittels eines Regelkreises (\emph{control loop}) nachzuführen (\emph{to track}). 

\FGimg{Trackingloop.png}{Blockschaltbild des GPS Trackingloops. Der Trackingloop besteht aus zwei Regelkreisen, die die LO-Frequenz bzw. die Codefrequenz nachführen.}{0.9\textwidth}

\FR{Trackingloop.png} zeigt ein Blockschaltbild des Trackingloops. Im folgenden werden kurz die Funktionen der einzelnen Blöcke erklärt. Anschließend wird ein Überblick über die Funktion des gesamten Trackingloops gegeben. Eine detaillierte Beschreibung des ist in \cite{borre2007software} zu finden.

\paragraph{Carrier NCO} Der Carrier \gls{NCO} generiert eine lokale Kopie des (ZF-)Trägers (unter Berücksichtigung der Dopplerverschiebung). Die Frequenz des NCOs ist digital einstellbar.

\paragraph{Carrier Mischer} Die zwei Carrier Mischer mischen das Eingangssignal $\gpsin$ mit dem von dem NCO erzeugten LO Signal $\gpslo_I$ bzw. $\gpslo_Q$. Bei korrekter Einstellung des NCO wird das Eingangssignal von  $f_{ZF}+f_{Doppler}$ herunter auf \SI{0}{\Hz} gemischt.

\paragraph{Carrier Loop Diskriminator} Der Carrier Loop Discriminator analysiert das heruntergemischte Signal, und generiert eine Signal, dass den Phasenfehler angibt.

\paragraph{Carrier Loop Filter} Der Carrier Loop Filter wirkt als \emph{PI-Glied} (\emph{Proportional, Integral}) in dem Regelkreis: Der NCO erwartet eine Frequenz als Steuersignal. Das Ausgangssignal des Carrier Loop Discriminator ist aber ein Phasenfehler. Der Carrier Loop Filter integriert (\emph{I-Glied}) den Phasenfehler, denn $\omega(t)=\frac{\partial \phi(t)}{\partial t}$ und addiert dazu (\emph{P-Glied}) den in der Acquisition bestimmten Wert für die Trägerfrequenz.

\paragraph{C/A Code Generator} Der \gls{CA} Code Generator erzeugt eine drei Kopien des Codes. Dabei ist die Codefrequenz, also die Geschwindigkeit mit der die Codesequenz \enquote{abgespielt} wird, digital einstellbar. Vereinfacht gesagt  funktioniert der C/A Code Generator intern als \gls{NCO} der ein Taktsignal für die erzeugenden \gls{LFSR} generiert. Die drei Kopien unterscheiden sich leicht in der Codephase, üblicherweise um die Dauer eines $\frac{1}{2}$ Chips. Deshalb werden die Kopien mit \emph{Early}, \emph{Prompt} und \emph{Late} bezeichnet. Der Zweck dieser drei Pfade wird weiter unten erläutert (TODO Link?).

\paragraph{Code Mischer} Nach der Mischung mit dem LO Signal wird das Signal $\gpsmx_I$ bzw. $\gpsmx_Q$ mit den Kopien des Codes gemischt. Nach der Mischung mit dem Code entspricht das Signal $\gpsxc_{I,P}$ theoretisch bereits wieder dem Datensignal $\gpsdat$.

\paragraph{Integrate \& Dump} Für die Funktion des Regelkreises werden die Signal $\gpsxc$ jeweils über eine Code Periode gemittelt (integriert). Der \emph{Dump}, also das Speichern des Integrationswerts und Zurücksetzen des Integrators auf null, muss dabei Synchron zu den Code Perioden erfolgen. Die Integratoren wirken gleichzeitig als Tiefpassfilter für die PLL.

\paragraph{Code Diskriminator} Der Code Diskriminator berechnet aus seinen Eingangswerten ein Steuersignal, das bestimmt ob die Codephase erhöht oder verringert werden muss.

\paragraph{Code Loop Filter} Genau wie der Carrier Loop Filter ist der Code Loop Filter ein \emph{PI-Glied} und erzeugt aus dem Phasenfehlersignal des Code Diskriminators ein Steuersignal für den NCO im C/A Code Generator.

\subsubsection{Carrier Tracking}
Zum Synchronisieren der LO Frequenz mit der Trägerfrequenz des Empfangssignals wird im Allgemeinen ein Phase Locked Loop (PLL) verwendet, der versucht die Phasendifferenz zwischen Eingangssignal und LO Signal auf null zu halten. Im Falle des GPS Signals ist jedoch zu beachten, dass der Träger BPSK moduliert ist, also Phasendifferenzen von \SI{0}{\degree} oder \SI{180}{\degree} gewollt sind. Eine Variante von PLL die diesen \SI{180}{\degree} Phasenfehler ignoriert ist der Costas Loop (\FR{Costasloop.png}), benannt nach dem Erfinder John P. Costas \cite{CostasSyncComm}.

\FGimg{Costasloop.png}{Der Costas Loop ist eine PLL Variante, die \gls{BPSK} modulierte Signale demodulieren kann.}{0.8\textwidth}

Dazu erzeugt der LO zwei Kopien des Trägers, die zueinander \SI{90}{\degree} verschoben sind: $\gpslo_I=\cos(\omega_{f} t)$ und  $\gpslo_Q=\sin(\omega_{f} t)$. Das Eingangssignal $\gpsin=\gpsdat \cdot \cos(\omega_{ZF} \cdot t)$ wird im jeweiligen Arm mit dem $I$ bzw $Q$ Träger gemischt und Tiefpassgefiltert:
\begin{eqnarray}
	\gpsmx_I &=& \gpsin \cdot \cos(\omega_{f} t)\\
		    &=& \gpsdat \cdot \cos(\omega_{ZF} \cdot t) \cdot \cos(\omega_{f} t)\\
            &=& \frac{\gpsdat}{2} \cdot (\cos((\omega_{ZF}-\omega_{f}) t)+ \cos((\omega_{ZF}+\omega_{f}) t)) \\
    \gpsout_I &=& \frac{\gpsdat}{2} \cdot \cos((\omega_{ZF}-\omega_{f})\cdot t)
\end{eqnarray}
Der hintere Term wird durch das Tiefpassfilter entfernt. Im Q-Pfad ergibt sich nach ähnlicher Rechnung:
\begin{eqnarray}
\gpsmx_Q &=& \frac{\gpsdat}{2} \cdot (\sin((\omega_{ZF}-\omega_{f}) t)+ \sin((\omega_{ZF}+\omega_{f}) t))\\
\gpsout_Q &=& \frac{\gpsdat}{2} \cdot \sin((\omega_{ZF}-\omega_{f})\cdot t)
\end{eqnarray}
Man sieht nun, dass wenn $\omega_{ZF}=\omega_{f}$ gilt, dann $\gpsout_I = \frac{\gpsdat}{2}$  und $\gpsout_Q =0$. Das Ziel des Regelkreises ist also die gesamte Energie im $I$-Arm zu halten. 
Dazu vergleicht der Loopdiskriminator die Energie im I und Q Arm, und generiert ein entsprechendes Steuersignal falls das Regelziel nicht erfüllt ist. Als Loopdiskriminator bietet sich $\arctan\left(\frac{Q}{I}\right)$ an, denn: 
\begin{equation}
	\frac{\gpsout_Q}{\gpsout_I} = \frac{ \frac{\gpsdat}{2} \cdot \sin((\omega_{ZF}-\omega_{f})\cdot t)}{\frac{\gpsdat}{2} \cdot \cos((\omega_{ZF}-\omega_{f})\cdot t)} = \tan({\underbrace{(\omega_{ZF}-\omega_{f})\cdot t}_{\phi_f}})
\end{equation}
Die Charakteristik des TODO arctan Diskriminators ist in Grafik TODO dargestellt. Wie man sieht hat die $\arctan()$ Funktion Nullstellen für \SI{0}{\degree} und \SI{180}{\degree}, woraus sich die Immunität gegen die BPSK Modulation ergibt.

\paragraph{Code Tracking}
Der Code Tracking Loop ist dafür zuständig die Phase des Codegenerators so anzupassen, dass sie mit der Phase des Codes im Empfangssignal übereinstimmt. In dieser Arbeit wurde dafür ein \emph{Early-Late-Gate} verwendet. Bei diesem wird das Signal parallel mit drei Kopien des Codes multipliziert, wobei die drei Codekopien zeitlich zueinander verzögert sind, üblicherweise um die Dauer $\frac{1}{2}$ Chips. Die drei Kopien werden mit \emph{Early} (\enquote{verfrüht}), \emph{Prompt} (\enquote{pünktlich}) und \emph{Late} (\enquote{verspätet}) bezeichnet. Bei korrekter Codephase wird die Energie im \emph{Prompt} Zweig am höchsten sein, und die Energie in den \emph{Early} und \emph{Late} Zweigen gleich groß. Falls die Phase des Codes dagegen zu klein eingestellt ist, wird die Energie im \emph{Late} Zweig steigen, und der Code Loop Diskriminator regelt entsprechend gegen.

\paragraph{Loop Filter}
Der Ausgang der Carrier- bzw. Code Loop Diskriminatoren ist der Wert des Phasenfehlers. Zur Ansteuerung des (TODO Glossar) NCO wird .