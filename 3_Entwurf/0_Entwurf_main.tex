\chapter{Entwurf}
Einleitung zum Entwurf

\section{Anforderungen}
In diesem Abschnitt sollen zunächst die Anforderungen genannt werden, anhand derer sich die Arbeitspakete identifizieren lassen. Das Ziel ist: Der \dscubesat soll in der Lage sein seine eigene Position mittels GPS zu bestimmen.  

\paragraph{Anzahl der Kanäle} Wie in Abschnitt \ref{positionsbestimmung} erläutert werden dazu die Daten von mindesten 4 GPS Satelliten benötigt. Daraus ergibt sich die Anforderung, dass der Empfänger mindestens 4 Kanäle zum Tracking der Signale haben muss. Weiterhin soll bei einem Verbindungsabbruch zu einem der 4 Satelliten die Positionsbestimmung nicht abbrechen, weshalb >4 Kanäle erforderlich sind. Außerdem steigt die Genauigkeit der Positionsbestimmung mit mehr Satelliten. Deshalb soll der hier entwickelte GPS Empfänger mindestens 6 Kanäle umfassen.

\paragraph{Rohdatenpuffer}
Voraussetzung für das Tracking ist die erfolgreiche Acquisition. 

dazu mindestens \SI{2}{\ms} Rohdaten erforderlich. 

\paragraph{Frontend Samplingrate}
Bei der Wahl der Frontend Für einen kleinen Pseudoranging Fehler sind hohe Samplingraten des GPS Frontends von Vorteil ($\epsilon_{r} = c_0/f_S$). Allerdings steigt mit höherer Samplingrate auch der Rechenaufwand bei der Acquisition.

 
% Die Voraussetzungen sind dafür: NAV Daten von >= 4 Satelliten
% Also müssen mindestens 4 Satelliten getrackt werden können. (plus Reserve falls Empfang verloren geht)
% Voraussetzung für das Tracking ist die Acquisition. Für die Acquisition werden 2ms Rohdaten benötigt. --> Speicheranforderung. Berechnung durchführen.
% Aus Experimenten mit verschieden Konfigurationen hat sich gezeigt, dass die besten Ergebnisse mit 1 bit sampling und einer ZF von xx Hz erzielt werden können, bei einer Samplingrate von xyz Hz. Das Frontend bietet zwar höhere Quantisierungen, jedoch führt dies offenbar i

% # CHannels
% Samplingrate
% Sample länge

\section{Planung}
Um die Arbeitspakete und Anforderungen zu identifizieren ist es zunächst wichtig zu verstehen wie die Demodulation des GPS Signals prinzipiell abläuft. Dies wird deshalb im ersten Abschnitt beschrieben. Im zweiten Abschnitt werden die Arbeitspakete dann den einzelnen Hardware Komponenten zugeordnet. Da die COM Hardware mit dem DSP und dem FPGA zwei komplexe Datenverarbeitende Komponenten besitzt, die Daten miteinander austauschen wird im dritten Abschnitt der Entwurf der Software Schnittstelle zwischen DSP und FPGA beschrieben. Der letzte Abschnitt beschreibt die Simulation, von der während des Entwurfs und Implementierung viel Gebrauch gemacht wurde, um Konzepte und Ideen zu prüfen.

% Meilensteine:
% Daten von Frontend nehmen, puffern und an DSP Übertragen
%% Kerneltreiber schreiben
%%% SPI, DMA
%% FIFO im FPGA implementieren
%%% EBIU Schnittstelle/State Machine
% Damit Acquisition in Matlab durchführen
% Trackingloop in Matlab simulieren
%% High Level (LUT, sin, cos)
%% Dann Low Level (LFSR, NCO)
% Implementierung Tracking FPGA
% Softwareschnittstelle FPGA<-> DSP
% Implementierung Acquisiton DSP


\paragraph{Entwurf der Parameter für die Acquisition}
Die wichtigen Parameter für die Acquisiton sind die Grenzen des zu durchsuchenden Raums.
Die derzeit aktiven Satelliten haben die Codes mit den PRN 1-32 zugewiesen. Der Bereich der möglichen Codephasen ergibt sich aus der Dauer einer Codeperiode (Codelänge/Chippingrate TODO), und der Sampling Frequenz des Frontend ICs (TODO Formel): N=fs/(fchip/Lcode)=16.369MHz/(1.023Mchip/s/1023) = 16369 MHz *TODO Fußnote: Die Samplingfrequenz im Flugmodell beträgt 16.368 MHz).

Da der Doppler Shift die Hauptursache ist entspricht die Abweichung dem maximal erwarteten Doppler Shift. Wie in Kapitel (todo link) besprochen, ist der erwartete Doppler Shift (TODO +-)45 kHz.

Die Schwelle ab der ein Signal nach dem ersten Schritt der Acquisition als „vorhanden“ bewertet wird wird auf ein Peak-to-Average Ratio von 2,5 festgelegt. Dieser Wert wurde durch Simulation für Signale gefunden, die ein gerade noch ausreichendes SNR haben.




Die entscheidenden Entwurfsparameter für den Carrier- und Code Tracking Loop sind die Parameter Dämpfungsgrad und Bandbreite des Loopfilters. Zusammen bestimmen diese die Schnelligkeit mit der der Regelkreis einrastet und die Rauschbandbreite des Steuersignals für den LO.
Die Werte für den Loopfilter wurden zunächst aus (TODO Referenz Buch) übernommen und anschließend, im Hinblick auf den höheren Dynamikbereich der Dopplerverschiebung auf dem Dragsail Cubesat überprüft. Die Extremwerte der Änderungsrate der Dopplerverschiebung wurden bereits in Abschnitt (TODO Link) bestimmt, und sind noch einmal in Tabelle (TODO Tabelle max Dopplershift, Dopplershift Änderung) dargestellt.
In der Simulation ergab sich, dass die Werte auch für den hier vorliegenden Anwendungsfall optimal sind. Tabelle TODO stellt die verwendeten Loop Filter Werte dar.

\paragraph{Filter Topologie und Festkommaentwurf}
Im Hinblick auf die Echtzeitfähigkeit und Stabilität des Regelkreises muss auf die Performanz und die begrenzte Rechengenauigkeit, der Berechnungen geachtet werden. Während in der Matlab Simulation, die nicht Echtzeitfähig ist, mit Fließkommawerten doppelter Genauigkeit gerechnet wird, soll in der Implementierung mit Festkommawerten gerechnet werden.
Dafür sind die Filterkoeffizienten zu quantisieren, und die Filtertopologie so anzupassen, dass der durch die Festkommazahl darstellbare Dynamikbereich optimal ausgenutzt wird. Die Details des Festkomma Entwurfs werden im Folgenden besprochen.

%\subsubsection{NAV Daten Auswertung}
%Präambel usw

\subsection{Arbeitsteilung FPGA/DSP}
% Acquisition im DSP
% Erfordert große Mengen Speicher und hoher Rechenaufwand
% Tracking im FPGA. Tracking erfordert hohe Parallelität bei moderatem Rechenaufwand und hat harte Echtzeitanforderungen.
% Softcore Prozessor. Auswahl. Aufgabe

\subsection{Softwareschnittstelle FPGA/DSP}
%Character Device Treiber
%Je Kanal ein FIFO

\subsection{Matlab Simulation}
%Trackingloop in Simulink

%High Level Simulation sukzessive angepasst an Implementierung in Hardware
%Acquisition Skripte
% MAX2769 Bandpassfilter mittenfrequenz
% 1bit vs >1bit: Große Störungen bemerkt bei >1bit