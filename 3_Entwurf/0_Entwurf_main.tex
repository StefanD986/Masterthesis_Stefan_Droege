\chapter{Entwurf}
Einleitung zum Entwurf

\section{Anforderungen}
In diesem Abschnitt sollen zunächst die Anforderungen genannt werden, anhand derer sich die Arbeitspakete identifizieren lassen. Das Ziel ist: Der \dscubesat soll in der Lage sein seine eigene Position mittels GPS zu bestimmen. Einige Anforderungen ergeben sich außerdem aus der Konfiguration des Frontends, weshalb auch diese hier besprochen wird.

\subsection{Anzahl der Kanäle} Wie in Abschnitt \ref{positionsbestimmung} erläutert werden zur Positionsbestimmung die Daten von mindesten 4 GPS Satelliten benötigt. Daraus ergibt sich die Anforderung, dass der Empfänger mindestens 4 Kanäle zum Tracking der Signale haben muss. Weiterhin soll bei einem Verbindungsabbruch zu einem der Satelliten die Positionsbestimmung nicht abbrechen, weshalb $>4$ Kanäle erforderlich sind. Außerdem steigt die Genauigkeit der Positionsbestimmung mit mehr Satelliten. Deshalb soll der hier entwickelte GPS Empfänger mindestens 6 Kanäle umfassen.

\subsection{Rohdatenpuffer}
Voraussetzung für das Tracking ist die erfolgreiche Acquisition, wofür eine gewisse Menge Rohdaten benötigt werden. Aufgrund der Bitwechsel Problemetik (\ref{DatenmengeAcq}) beträgt die maximal sinnvolle Pufferlänge $2\times\SI{10}{\ms}$. Für den Entwurf wurde sich an der Implementierung in der Simulation in \cite{borre2007software} orientiert, wo ein \SI{10}{\ms} Segment in der zweiten Phase der Acquisition verwendet wird.

\subsection{Komponenten und benötigte Daten für Acquisition und Positionsbestimmung}
In \FR{GPS_UML_component1.pdf} sind die Komponenten dargestellt, und die von ihnen bereitgestellten bzw. benötigten Daten. Das Diagramm macht noch keine Aussage darüber wo (ob auf DSP oder FPGA) oder wie die Komponenten realisiert werden.

Die Komponente \emph{Acquisition} benötigt das oben genannten Segment Rohdaten. Die Acquisition Ergebnisse beziehen sich außerdem immer auf die Rohdaten und damit auf einen bestimmten Zeitpunkt. Für die Acquisition selbst ist der Zeitpunkt nicht wichtig, aber beim Initialisieren der Trackingloops wird die Information benötigt, und muss daher irgendwo festgehalten werden. Die Trackingloops erhalten von dem Frontend Rohdaten (anders als die Acquisition Komponente allerdings als kontinuierlichen Datenstrom) und demodulieren das Signal. Aus dem demodulierten Signal extrahiert die \emph{NAV Daten Extraktion} Komponente die NAV Daten. Wie in Abschnitt \ref{positionsbestimmung} erklärt, reichen die NAV Daten alleine zu Positionsbestimmung nicht aus. Deshalb benötigt die Komponente \emph{Positionsbestimmung} diese zusätzliche Information noch von den Trackingloops.


\FGimg[Komponentendiagramm GPS Empfänger]{GPS_UML_component1.pdf}{Die abstrahierten Komponenten des GPS Empfängers und die von ihnen benötigten bzw. bereitgestellten Daten.}{0.8\textwidth}

\subsection{Frontend Parameter}
Die wichtigsten Parameter des Frontend sind die ZF Frequenz - und damit die PLL Parameter - die Einstellung des ZF Filters, und die Parameter des AD Wandlers. Die Dokumentation des MAX2769 Frontend ICs ist leider an vielen Stellen sehr lückenhaft. Daher mussten die optimalen Einstellungen teils durch Ausprobieren ermittelt werden.

\begin{table}[htbp]
    \ttabbox
    {
        \caption[Zusammenfassung Frontend Parameter]{Übersicht der wichtigsten Frontend Parameter}
        \label{TabFrontendParams}
    }
    {
        \rowcolors{2}{light-gray}{White}
    \begin{tabular}{c S l}
        \toprule
        Bezeichnung             &  {Wert} & Anmerkung\\
        \midrule
        $f_{ZF}$      & \SI{2.048}{\MHz}      & Zwischenfrequenz\\
        $f_{LO}$      & \SI{1573.374}{\MHz}   & Lokaloszillator\\
        NDIV        & \num{1538}            & PLL Hauptteiler\\
        RDIV        & \num{16}              & PLL Referenzteiler\\
        $f_S$       & \SI{16.368}{\MHz}     & Samplingrate \\
        $m$           & \num{1}               & Quantisierer Bits \\
        \bottomrule
    \end{tabular}
    }
\end{table}

\FGimg[Vereinfachtes MAX2769 Blockschaltbild]{FrontendSimplified.png}{Vereinfachtes Blockschaltbild des MAX2769 GPS Frontends. Vor dem Mischer filtert ein externer Bandpass das GPS L1 Signal.}{0.9\textwidth}

\paragraph{ZF und PLL Parameter}
Bei der Erzeugung des LO Signals stehen im Frontend eine Integer PLL oder eine Fractional PLL zur Auswahl. Experimentell wurde bestimmt, dass die Integer PLL weniger Interferenzen verursacht, und die besten Ergebnisse bei einer ZF von etwa \SI{2}{\MHz} erreicht werden können. Bei der Auswahl der PLL Teilerfaktoren muss darauf geachtet werden, dass die geteilten Frequenzen in den im Datenblatt \cite{max2769} angegebenen Grenzen bleiben und $f_{comp}=f_{ref}/R$ muss zu dem Loop Filter der Frontend PLL passen. Das \comboard verwendet für den Loop Filter die Werte aus dem Datenblatt, wonach $f_{comp}=\SI{1.023}{\MHz}$ sein soll. Falls der komplexe Bandpass verwendet wird, muss außerdem die LO Frequenz unterhalb der Eingangsfrequenz liegen, da der komplexe Bandpass das untere Seitenband herausfiltert.
Mit dem \SI{16.368}{MHz} \gls{TCXO} auf dem \comboard ergibt sich damit $R=16$. $f_ZF$ soll im Bereich \SI{2}{\MHz} liegen, womit $N=1538$ zu wählen ist. Damit ergibt sich $f_{ZF}=f_{L1}-f_{TCXO}\cdot \frac{N}{R}=\SI{2.046}{MHz}$.

\paragraph{ZF Filter}
Als Konfiguration für das ZF Filter im Frontend wurde das komplexe Bandpassfilter gewählt. Das komplexe Bandpassfilter ist bei Anwendungen mit einer ZF $\neq 0$ zu bevorzugen, da damit die Spiegelfrequenzen unterdrückt werden\footnote{Falls die ZF zu \SI{0}{\Hz} gewählt wird sollte als ZF Filter das reelle Tiefpassfilter gewählt werden, um Satellitensignale mit negativer Doppleverschiebung nicht zu unterdrücken.}. Die untere Schranke für die Bandbreite ergibt sich aus dem Shannon-Nyquist Theorem zu $B\geq 2/\gpsTchip=\SI{1.023}{\MHz}$. Jegliche Filterung verschlechtert zwar das $E_b/N_0$, ist allerdings erforderlich um Aliasing bei der AD Wandlung zu verhindern. Wie in \cite{hegarty2011analytical} und \cite{itc1982chang} untersucht wurde, bringen allerdings Bandbreiten $B>2/\gpsTchip$ nur marginal geringere Verschlechterungen. \cite{hegarty2011analytical} nennt zum Beispiel eine Verbesserung von lediglich \SI{0.41}{\dB} wenn statt $B=2/\gpsTchip$ eine Bandbreite von $B=10/\gpsTchip$ gewählt wird. Deshalb wurde als Bandbreite $B=\SI{2.5}{\MHz}$ gewählt.

Die Mittenfrequenz $f_{cen}$ des ZF Filters lässt sich auf die gewählte ZF über ein \SI{6}{\bit} Konfigurationswort ($\textrm{FCEN}$) anpassen. Die Berechnung des Konfigurationsworts ist leider nicht im MAX2769 Datenblatt dokumentiert, es konnte aber herausgefunden werden, dass das korrekte Konfigurationswort mit folgender Gleichung ermittelt werden kann: 
\begin{equation}
    \textrm{FCEN'} = 64 - \frac{f_{cen}}{\Delta f}
\end{equation}
wobei $\textrm{FCEN'}$ das gespiegelte Konfigurationswort $\textrm{FCEN}$ ist (wenn z.B. $\textrm{FCEN'}=101100$, dann ist $\textrm{FCEN}=001101$) und $\Delta f=\SI{0.195}{\MHz}$  für $B=\SI{0.195}{\MHz}$.

\paragraph{Quantisierung und Samplingrate}
Zusätzlich zu der Bandpassfilterung wird auch durch Quantisierung und Abtastung das $E_b/N_0$  des Signals leicht verschlechtert. Der genaue Zusammenhang wurde ebenfalls in \cite{hegarty2011analytical} und \cite{itc1982chang} untersucht. Wie \cite{itc1982chang} schreibt hängt die Verschlechterung vor allem von der Anzahl der Bits $m$ des Quantisierers, schwach von dem Produkt $B\cdot T$ und nur sehr schwach vom $E_b/N_0$ des Eingangssignals ab. \TR{TabDegradQuant} stellt die Werte für verschiedene Anzahl von Bits für einen Empfänger ohne Bandpassfilterung und hoher Abtrastrate dar. Das trotzdem auch viele kommerzielle GPS Empfänger lediglich 1-bit Quantisierer verwenden liegt zum einen daran, dass die Verschlechterung nicht sehr gravierend ist und zum anderen daran, dass sich dadurch die Implementierung stark vereinfacht: Die Mischer können durch einfache XOR Glieder implementiert werden, es sind keine Look-Up Tables für den Lokaloszillator notwendig usw. 

Trotzdem wurden einige Untersuchungen angestellt, welchen Vorteil höhere Quantisierungen in der Praxis bringen. Dabei stellte sich jedoch heraus, dass der Störabstand im Vergleich zu 1-bit Sampling sinkt. Als Ursache wurde vermutet, dass die zusätzlichen Schaltvorgänge innerhalb des ICs für Interferenzen sorgen. Aus diesem Grund verwendet auch der in dieser Arbeit entwickelte Empfänger nur 1 bit und nur die reellen ($I$) Samples.


\begin{table}[htbp]
    \ttabbox
    {
        \caption[$E_b/N_0$ Verschlechterung durch Quantisierung]{Kleinste mögliche $E_b/N_0$ Verschlechterung durch Quantisierung für verschiedene Anzahl von Bits. Gültig für einen Empfänger ohne Bandpassfilterung und hohe Abtastraten (aus \cite{hegarty2011analytical}).}
        \label{TabDegradQuant}
    }
    {
        \rowcolors{2}{light-gray}{White}
    \begin{tabular}{c c}
        \toprule
        \# Bits             &  Verschlechterung (dB)\\
        \midrule
        \num{1}         & \num{1,961} \\
        \num{1.5}    & \num{0.916} \\
        \num{2}           & \num{0.549} \\
        \num{2.5}    & \num{0.372} \\
        \num{3}           & \num{0.166} \\
        \bottomrule
    \end{tabular}
    }
\end{table}

Die Samplingrate kann über Teiler und Vervielfacher die Werte $\gpsftcxo$, $\gpsftcxo/2$, $\gpsftcxo/4$, oder $2\times \gpsftcxo$ annehmen\footnote{Es gibt außerdem noch ein Fractional Clock Divider, über den noch andere Teilraten eingestellt werden können.}. Bei der Auswahl muss ein Kompromiss gemacht werden zwischen Genauigkeit der Pseudorange Schätzung (\ref{positionsbestimmung}) und dem Speicherverbrauch für den Rohdatenpuffer. Unter Berücksichtigung der oben festgelegten Größe des Rohdatenpuffers \SI{10}{\ms} wird die Samplingrate auf  $f_S=\gpsftcxo=\SI{16.368}{\MHz}$ festgelegt. Damit werden mit dem 1-bit Quantisierer mindestens \SI{163.69}{\kilo\bit} Speicher benötigt\footnote{Weil der Puffer als FIFO implementiert wird sind Speichergrößen von Zweierpotenzen vorteilhaft. Daher umfasst der Puffer \SI{262144}{\bit}, und damit etwa \SI{16}{\ms}}.

\paragraph{Andere Einstellungen} Neben den oben genannten Parametern bietet das MAX2769 Frontend noch viele weitere Einstellungen. Die meisten wurden dabei auf den Voreinstellungen belassen. Abweichend davon wurde beim Flugmodell die Phantomspeisung abgeschaltet und LNA1 ausgewählt, da dieser für passive Antennen ausgelegt ist wie sie im \dscubesat verwendet werden\footnote{Bei dem COM1 Board wurde währende der Entwicklung eine aktive Antenne und der dafür optimierte LNA2 verwendet.}. Die \gls{AGC} ist zwar aktiviert, dürfte aber bei 1-Bit Sampling keinen Einfluss haben. Der \emph{GAINREF} Parameter wurde auf 255 gesetzt. Weiterhin wurde durch ausprobieren herausgefunden, dass sich die Erfolgsrate der Acquisition leicht verbessert wenn der Hochpassfilter vor dem \gls{PGA} abgeschaltet wird (\emph{FHIPEN}$=0$).

\subsection{Echtzeitanforderungen} \label{echtzeitanforderungen}
Die beiden Phasen Acquistion und Tracking haben unterschiedliche Echtzeitanforderungen: Das Tracking hat harte Echtzeitanforderungen: Erstens müssen laufend Träger- und Codekopie erzeugt und mit dem Eingangssignal multipliziert werden. Dies sind die höchsten Echtzeitanforderungen im \si{\nano\second} Bereich, da dies je Sample, also alle $1/f_S$ geschehen muss. Die Neuberechnung der Loop Parameter hat harte Echtzeitanforderungen im \si{\milli\second}, da dies lediglich nach jeder Integrationsdauer ($\gpsTcode=\SI{1}{\ms}$) passieren muss. Die Blöcke die lediglich Echtzeitanforderungen im \si{\milli\second} Bereich haben sind in \FR{Trackingloop.png} grün markiert.

Die Acquisition hat lediglich weiche Echtzeitanforderung im Sekundenbereich, da sich die Dopplerverschiebung nur relativ langsam verändert (schlimmstenfalls \SI{61}{\Hz/\second}, siehe \ref{maxdopplershift}). Falls die Acquisition länger als geplant dauert, kann der Trackingloop trotzdem noch einrasten wenn sich die Dopplerverschiebung nicht zu stark geändert hat.

\section{Planung}
Um die Arbeitspakete und Anforderungen zu identifizieren ist es zunächst wichtig zu verstehen wie die Demodulation des GPS Signals prinzipiell abläuft. Dies wird deshalb im ersten Abschnitt beschrieben. Im zweiten Abschnitt werden die Arbeitspakete dann den einzelnen Hardware Komponenten zugeordnet. Da die COM Hardware mit dem DSP und dem FPGA zwei komplexe Datenverarbeitende Komponenten besitzt, die Daten miteinander austauschen wird im dritten Abschnitt der Entwurf der Software Schnittstelle zwischen DSP und FPGA beschrieben. Der letzte Abschnitt beschreibt die Simulation, von der während des Entwurfs und Implementierung viel Gebrauch gemacht wurde, um Konzepte und Ideen zu prüfen.

\begin{enumerate}
\item Schnittstelle zum Übertragen der Rohdaten zum DSP
    \begin{enumerate}
    \item Kerneltreiber schreiben
    \item EBIU Schnittstelle im FPGA implementieren
    \item FIFO im FPGA implementieren
    \end{enumerate}
\item Simulation der Acquisition in Matlab
\item Simulation des Trackings in Matlab
    \begin{enumerate}
    \item Zuerst \emph{High Level} Simulation
    \item Sukzessive an die Implementierung im FPGA anpassen
    \end{enumerate}
\item Implementierung des Tracking im FPGA
    \begin{enumerate}
    \item Programmierbare Hardware
    \item Implementierung des Softcore Prozessors
    \item Schreiben der Firmware für den Softcore Prozessor
    \end{enumerate}
\item Implementierung der Acquisition im DSP
\item Extraktion der NAV Daten
\begin{enumerate}
    \item Frame Synchronisation
    \item \ldots
\end{enumerate}
\item Berechnung der Position
\end{enumerate}

% Meilensteine:
% Daten von Frontend nehmen, puffern und an DSP Übertragen
%% Kerneltreiber schreiben
%%% SPI, DMA
%% FIFO im FPGA implementieren
%%% EBIU Schnittstelle/State Machine
% Damit Acquisition in Matlab durchführen
% Trackingloop in Matlab simulieren
%% High Level (LUT, sin, cos)
%% Dann Low Level (LFSR, NCO)
% Implementierung Tracking FPGA
% Softwareschnittstelle FPGA<-> DSP
% Implementierung Acquisiton DSP


\paragraph{Entwurf der Parameter für die Acquisition}
Die wichtigen Parameter für die Acquisiton sind die Grenzen des zu durchsuchenden Raums.
Die derzeit aktiven Satelliten haben die Codes mit den PRN 1-32 zugewiesen. Der Bereich der möglichen Codephasen ergibt sich aus der Dauer einer Codeperiode (Codelänge/Chippingrate TODO), und der Sampling Frequenz des Frontend ICs (TODO Formel): N=fs/(fchip/Lcode)=16.369MHz/(1.023Mchip/s/1023) = 16369 MHz *TODO Fußnote: Die Samplingfrequenz im Flugmodell beträgt 16.368 MHz).

Da der Doppler Shift die Hauptursache ist entspricht die Abweichung dem maximal erwarteten Doppler Shift. Wie in Kapitel (todo link) besprochen, ist der erwartete Doppler Shift (TODO +-)45 kHz.

Die Schwelle ab der ein Signal nach dem ersten Schritt der Acquisition als „vorhanden“ bewertet wird wird auf ein Peak-to-Average Ratio von 2,5 festgelegt. Dieser Wert wurde durch Simulation für Signale gefunden, die ein gerade noch ausreichendes SNR haben.


Die entscheidenden Entwurfsparameter für den Carrier- und Code Tracking Loop sind die Parameter Dämpfungsgrad und Bandbreite des Loopfilters. Zusammen bestimmen diese die Schnelligkeit mit der der Regelkreis einrastet und die Rauschbandbreite des Steuersignals für den LO.
Die Werte für den Loopfilter wurden zunächst aus (TODO Referenz Buch) übernommen und anschließend, im Hinblick auf den höheren Dynamikbereich der Dopplerverschiebung auf dem Dragsail Cubesat überprüft. Die Extremwerte der Änderungsrate der Dopplerverschiebung wurden bereits in Abschnitt (TODO Link) bestimmt, und sind noch einmal in Tabelle (TODO Tabelle max Dopplershift, Dopplershift Änderung) dargestellt.
In der Simulation ergab sich, dass die Werte auch für den hier vorliegenden Anwendungsfall optimal sind. Tabelle TODO stellt die verwendeten Loop Filter Werte dar.

\paragraph{Filter Topologie und Festkommaentwurf}
Im Hinblick auf die Echtzeitfähigkeit und Stabilität des Regelkreises muss auf die Performanz und die begrenzte Rechengenauigkeit, der Berechnungen geachtet werden. Während in der Matlab Simulation, die nicht Echtzeitfähig ist, mit Fließkommawerten doppelter Genauigkeit gerechnet wird, soll in der Implementierung mit Festkommawerten gerechnet werden.
Dafür sind die Filterkoeffizienten zu quantisieren, und die Filtertopologie so anzupassen, dass der durch die Festkommazahl darstellbare Dynamikbereich optimal ausgenutzt wird. Die Details des Festkomma Entwurfs werden im Folgenden besprochen.

%\subsubsection{NAV Daten Auswertung}
%Präambel usw

\subsection{Arbeitsteilung FPGA/DSP}
% Acquisition im DSP
% Erfordert große Mengen Speicher und hoher Rechenaufwand. Floating Point
% Idee Vorberechnung im FPGA verworfen, Implementierungsaufwand Protokoll etc
% Tracking im FPGA. Tracking erfordert hohe Parallelität bei moderatem Rechenaufwand und hat harte Echtzeitanforderungen.
% Softcore Prozessor. Auswahl. Aufgabe
Das \comboard bietet mit dem DSP und dem FPGA zwei Rechenknoten an, die in verschiedenen Bereichen Vorteile und Nachteile haben: FPGAs eignen sich vor allem für gut parallelisierbare Aufgaben. Für sequentielle Aufgaben ist dagegen der Implementierungsaufwand hoch, da dies immer einen Zustandsautomaten erfordert. Im Falle des \comboard hat außerdem der DSP deutlich mehr Speicher zur Verfügung. Wie früher im Text schon besprochen haben die Acquisition und Tracking sehr unterschiedliche Anforderungen: Die Acquisition benötigt vor allem Speicher und der Ablauf (FFT, Maximumsuche, etc) ist vergleichsweise komplex. Die Echtzeitanforderungen sind bei der Acquisition nicht sehr hoch. Das Tracking dagegen hat harte Echtzeitanforderungen, aber der Rechenaufwand ist moderat, und der Ablauf ist recht einfach. Daher ist es sinnvoll die Aufgaben auf die beiden Komponenten aufzuteilen.

Der DSP kann seine Vorzüge bei der Acquisition ausspielen: Er hat einen großen Arbeitsspeicher, ist auf Signalverarbeitung ausgelegt und Programme können in einer Hochsprache wie C geschrieben werden, was nebenbei das Debugging vereinfacht.

Für das Tracking ist der FPGA ideal geeignet, da die $\geq 6$ Trackingkanäle in programmierbarer Hardware implementiert werden können und damit vollständig parallel ablaufen. Auch das Tracking erfordert allerdings einige Berechnungen, die sich einfacher in C als in VHDL beschreiben lassen. Um die Echtzeitanforderung einzuhalten werden diese Berechnungen aber nicht an den DSP übergeben. Stattdessen soll dies von einem Softcore Prozessor innerhalb FPGA der dort in programmierbarer Logik implement wird.

In \FR{GPS_UML_deployment1.png} ist die Verteilung der Komponenten auf die verschiedenen Rechenknoten dargestellt. Die Softcore CPU übernimmt die Berechnung der Loop Parameter für alle Trackingloops. Die \emph{Tracking} Kanäle benötigen zwar die Softcore CPU für die Funktion aber CPU und \emph{Tracking} Kanäle sind weitestgehend unabhängig und sind deshalb als eigenständige \emph{devices} modelliert. Im DSP soll die GPS Empfänger Anwendung laufen, die zum einen die Acquisition und zum anderen die weitere Signalverarbeitung zur NAV Daten Extraktion und Positionsbestimmung übernimmt. Auf der Hardware Ebene kommuniziert der DSP mit dem FPGA über die \gls{EBIU} Schnittstelle \cite{BlackfinHWReference}, die ein Interface für externen Speicher implementiert. 

\FGimg[Verteilungsdiagramm Dragsail GPS Empfänger]{GPS_UML_deployment1.png}{Verteilung der Komponenten auf die Rechenknoten des COM Boards}{0.9\textwidth}

% Komponenten: Acquisition, Tracking...
\subsection{Softwareschnittstelle FPGA/DSP}
In diesem Abschnitt wird die Schnittstelle auf der Software Ebene aus Sicht des DSP beschrieben. Eine Anmerkung vorab dazu: Die Beschreibung stellt den Stand zum Zeitpunkt der Entwicklungsphase dar, und wurde für die Rohdatenübertragung auch so implementiert. Für die weitere Entwicklung ist jedoch ein Wechsel auf das \emph{Linux User I/O} Framework angedacht, da dies die weitere Entwicklung vereinfachen wird. Einige Erklärungen dazu folgen im zweiten Unterabschnitt.



%Character Device Treiber
%Je Kanal ein FIFO
% Auf Software Seite werden die Kanäle durch Klassen repräsentiert. Abstraktion der Hardware Kanäle

\subsection{Matlab Simulation}
%Trackingloop in Simulink

%High Level Simulation sukzessive angepasst an Implementierung in Hardware
%Acquisition Skripte
% MAX2769 Bandpassfilter mittenfrequenz
% 1bit vs >1bit: Große Störungen bemerkt bei >1bit